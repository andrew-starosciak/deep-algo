//! Gabagool-style hybrid arbitrage detector.
//!
//! This implements the hybrid strategy observed from gabagool's wallet:
//!
//! 1. **Entry**: Wait for one side to drop below $0.35 (mispricing) while BTC spot
//!    confirms the direction vs window reference ("price to beat").
//!
//! 2. **Hedge**: If both sides become cheap enough (pair_cost < $0.97), buy BOTH
//!    to lock in guaranteed profit regardless of outcome.
//!
//! 3. **Scratch**: Exit unhedged positions before resolution if we can't hedge,
//!    accepting small loss to avoid binary outcome risk.
//!
//! # Key Insight
//!
//! Gabagool doesn't purely predict - they CONFIRM direction after BTC moves, then
//! enter the cheap side. If both sides become cheap, they hedge for guaranteed profit.
//! If they can't hedge before resolution, they scratch out near breakeven.
//!
//! This explains their 95-98% win rate: they're not predicting, they're confirming
//! and hedging.

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use rust_decimal_macros::dec;
use serde::{Deserialize, Serialize};

use super::reference_tracker::{ReferenceConfidence, WindowReference};

/// Configuration for the Gabagool detector.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GabagoolConfig {
    /// Maximum price to consider "cheap" for entry (e.g., $0.35).
    /// Gabagool enters when one side drops significantly below $0.50.
    pub cheap_threshold: Decimal,

    /// Minimum BTC price delta vs reference to confirm direction (e.g., 0.0005 = 0.05%).
    /// We only enter when spot has moved enough to give confidence in direction.
    pub min_reference_delta: f64,

    /// Maximum combined cost for pair hedge (e.g., $0.97).
    /// If YES + NO < this, we can lock in guaranteed profit.
    pub pair_cost_threshold: Decimal,

    /// Time (seconds) before window close to trigger scratch exit.
    /// If unhedged and this close to expiry, exit to avoid binary risk.
    pub scratch_time_secs: i64,

    /// Maximum loss to accept for scratch exit (e.g., $0.02).
    /// We'll scratch at entry_price - this amount.
    pub scratch_loss_limit: Decimal,

    /// Minimum time into window before considering entry (ms).
    /// Avoid entering right at window open when reference is being set.
    pub min_window_elapsed_ms: i64,

    /// Minimum reference confidence required to trade.
    pub min_reference_confidence: ReferenceConfidence,
}

impl Default for GabagoolConfig {
    fn default() -> Self {
        Self {
            // Gabagool appears to enter at prices up to ~$0.42
            cheap_threshold: dec!(0.42),
            // Lower delta threshold - gabagool enters with smaller moves (~$25 on $78k)
            min_reference_delta: 0.0003, // 0.03%
            pair_cost_threshold: dec!(0.97),
            scratch_time_secs: 180, // 3 minutes
            scratch_loss_limit: dec!(0.02),
            min_window_elapsed_ms: 30_000, // 30 seconds
            min_reference_confidence: ReferenceConfidence::Medium,
        }
    }
}

impl GabagoolConfig {
    /// Creates a more aggressive config for faster markets.
    /// Higher price threshold, lower delta requirement.
    #[must_use]
    pub fn aggressive() -> Self {
        Self {
            cheap_threshold: dec!(0.48), // Enter at almost fair value
            min_reference_delta: 0.0002, // 0.02% (~$15 on $78k)
            pair_cost_threshold: dec!(0.98),
            scratch_time_secs: 120, // 2 minutes
            scratch_loss_limit: dec!(0.03),
            min_window_elapsed_ms: 15_000, // 15 seconds
            min_reference_confidence: ReferenceConfidence::Low,
        }
    }

    /// Creates a conservative config for safer trading.
    /// Lower price threshold, higher delta requirement.
    #[must_use]
    pub fn conservative() -> Self {
        Self {
            cheap_threshold: dec!(0.35), // Only enter on significant mispricing
            min_reference_delta: 0.0005, // 0.05% (~$39 on $78k)
            pair_cost_threshold: dec!(0.95),
            scratch_time_secs: 300, // 5 minutes
            scratch_loss_limit: dec!(0.01),
            min_window_elapsed_ms: 60_000, // 1 minute
            min_reference_confidence: ReferenceConfidence::High,
        }
    }
}

/// The type of signal generated by the detector.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum GabagoolSignalType {
    /// Initial entry on the cheap side (directional bet confirmed by spot).
    Entry,
    /// Hedge the opposite side to lock in guaranteed profit.
    Hedge,
    /// Exit existing position to avoid binary outcome risk.
    Scratch,
}

/// Direction of the trade.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum GabagoolDirection {
    /// Buy YES - BTC is above reference, YES should win.
    Yes,
    /// Buy NO - BTC is below reference, NO should win.
    No,
}

impl GabagoolDirection {
    /// Returns the opposite direction.
    #[must_use]
    pub fn opposite(&self) -> Self {
        match self {
            Self::Yes => Self::No,
            Self::No => Self::Yes,
        }
    }
}

/// A detected opportunity or action signal.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GabagoolSignal {
    /// Type of action to take.
    pub signal_type: GabagoolSignalType,

    /// Direction (which side to buy).
    pub direction: GabagoolDirection,

    /// Price to pay for this side.
    pub entry_price: Decimal,

    /// Current BTC spot price.
    pub spot_price: f64,

    /// Window reference price ("price to beat").
    pub reference_price: f64,

    /// BTC delta vs reference (percent, e.g., 0.005 = 0.5%).
    pub spot_delta_pct: f64,

    /// Combined cost if both sides were bought now.
    pub current_pair_cost: Decimal,

    /// Time remaining in window (seconds).
    pub time_remaining_secs: i64,

    /// Signal generation timestamp.
    pub timestamp: DateTime<Utc>,

    /// Estimated edge (for Entry signals).
    pub estimated_edge: f64,

    /// For hedge signals: the existing entry price we're hedging.
    pub existing_entry_price: Option<Decimal>,

    /// Confidence in this signal (based on reference confidence).
    pub confidence: SignalConfidence,
}

/// Confidence level for a signal.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum SignalConfidence {
    /// Low confidence - proceed with caution.
    Low,
    /// Medium confidence - normal position size.
    Medium,
    /// High confidence - can use larger size.
    High,
}

impl From<ReferenceConfidence> for SignalConfidence {
    fn from(rc: ReferenceConfidence) -> Self {
        match rc {
            ReferenceConfidence::Low => Self::Low,
            ReferenceConfidence::Medium => Self::Medium,
            ReferenceConfidence::High => Self::High,
        }
    }
}

/// Tracks an open position for hedge/scratch logic.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenPosition {
    /// Direction of the position.
    pub direction: GabagoolDirection,
    /// Entry price.
    pub entry_price: Decimal,
    /// Quantity held.
    pub quantity: Decimal,
    /// Entry timestamp.
    pub entry_time_ms: i64,
    /// Window this position is for.
    pub window_start_ms: i64,
}

/// Market state snapshot for the detector.
#[derive(Debug, Clone)]
pub struct MarketSnapshot {
    /// Best ask for YES.
    pub yes_ask: Decimal,
    /// Best bid for YES.
    pub yes_bid: Decimal,
    /// Best ask for NO.
    pub no_ask: Decimal,
    /// Best bid for NO.
    pub no_bid: Decimal,
    /// Current timestamp (ms).
    pub timestamp_ms: i64,
}

impl MarketSnapshot {
    /// Creates a new market snapshot.
    #[must_use]
    pub fn new(
        yes_ask: Decimal,
        yes_bid: Decimal,
        no_ask: Decimal,
        no_bid: Decimal,
        timestamp_ms: i64,
    ) -> Self {
        Self {
            yes_ask,
            yes_bid,
            no_ask,
            no_bid,
            timestamp_ms,
        }
    }

    /// Creates a snapshot with just asks (bids default to asks - spread).
    #[must_use]
    pub fn from_asks(yes_ask: Decimal, no_ask: Decimal, timestamp_ms: i64) -> Self {
        Self {
            yes_ask,
            yes_bid: yes_ask - dec!(0.01),
            no_ask,
            no_bid: no_ask - dec!(0.01),
            timestamp_ms,
        }
    }

    /// Returns the pair cost (YES ask + NO ask).
    #[must_use]
    pub fn pair_cost(&self) -> Decimal {
        self.yes_ask + self.no_ask
    }
}

/// The Gabagool-style hybrid arbitrage detector.
#[derive(Debug)]
pub struct GabagoolDetector {
    config: GabagoolConfig,
    /// Current open position (if any).
    open_position: Option<OpenPosition>,
    /// Last signal timestamp (for cooldown).
    last_signal_ms: Option<i64>,
    /// Cooldown between signals (ms).
    signal_cooldown_ms: i64,
}

impl GabagoolDetector {
    /// Creates a new detector with the given config.
    #[must_use]
    pub fn new(config: GabagoolConfig) -> Self {
        Self {
            config,
            open_position: None,
            last_signal_ms: None,
            signal_cooldown_ms: 5_000, // 5 second cooldown
        }
    }

    /// Creates a detector with default config.
    #[must_use]
    pub fn with_defaults() -> Self {
        Self::new(GabagoolConfig::default())
    }

    /// Sets the signal cooldown period.
    #[must_use]
    pub fn with_cooldown(mut self, cooldown_ms: i64) -> Self {
        self.signal_cooldown_ms = cooldown_ms;
        self
    }

    /// Returns the current config.
    #[must_use]
    pub fn config(&self) -> &GabagoolConfig {
        &self.config
    }

    /// Returns the current open position.
    #[must_use]
    pub fn open_position(&self) -> Option<&OpenPosition> {
        self.open_position.as_ref()
    }

    /// Records that we entered a position.
    pub fn record_entry(&mut self, position: OpenPosition) {
        self.open_position = Some(position);
    }

    /// Records that we exited (scratched or hedged).
    pub fn record_exit(&mut self) {
        self.open_position = None;
    }

    /// Checks for trading opportunities.
    ///
    /// This is the main entry point. It will return:
    /// - `Entry` signal if one side is cheap and spot confirms direction
    /// - `Hedge` signal if we have a position and can lock in pair arb
    /// - `Scratch` signal if we have a position and need to exit before expiry
    /// - `None` if no action needed
    pub fn check(
        &mut self,
        reference: &WindowReference,
        spot_price: f64,
        market: &MarketSnapshot,
    ) -> Option<GabagoolSignal> {
        // Check cooldown
        if let Some(last) = self.last_signal_ms {
            if market.timestamp_ms - last < self.signal_cooldown_ms {
                return None;
            }
        }

        // Check reference confidence
        if reference.confidence < self.config.min_reference_confidence {
            return None;
        }

        // Check timing - are we in a valid window?
        if !reference.is_active(market.timestamp_ms) {
            return None;
        }

        let elapsed_ms = reference.time_elapsed_ms(market.timestamp_ms);
        if elapsed_ms < self.config.min_window_elapsed_ms {
            return None;
        }

        let time_remaining_ms = reference.time_remaining_ms(market.timestamp_ms);
        let time_remaining_secs = time_remaining_ms / 1000;

        // Calculate spot delta vs reference
        let spot_delta_pct = reference.price_change_ratio(spot_price);

        // Check if we have an open position
        if let Some(position) = &self.open_position {
            // Check for scratch (exit before expiry)
            if let Some(signal) = self.check_scratch(
                position,
                reference,
                spot_price,
                market,
                time_remaining_secs,
                spot_delta_pct,
            ) {
                self.last_signal_ms = Some(market.timestamp_ms);
                return Some(signal);
            }

            // Check for hedge opportunity
            if let Some(signal) = self.check_hedge(
                position,
                reference,
                spot_price,
                market,
                time_remaining_secs,
                spot_delta_pct,
            ) {
                self.last_signal_ms = Some(market.timestamp_ms);
                return Some(signal);
            }
        } else {
            // No position - check for entry
            if let Some(signal) = self.check_entry(
                reference,
                spot_price,
                market,
                time_remaining_secs,
                spot_delta_pct,
            ) {
                self.last_signal_ms = Some(market.timestamp_ms);
                return Some(signal);
            }
        }

        None
    }

    /// Checks for entry opportunity.
    fn check_entry(
        &self,
        reference: &WindowReference,
        spot_price: f64,
        market: &MarketSnapshot,
        time_remaining_secs: i64,
        spot_delta_pct: f64,
    ) -> Option<GabagoolSignal> {
        let abs_delta = spot_delta_pct.abs();

        // Need sufficient delta to confirm direction
        if abs_delta < self.config.min_reference_delta {
            return None;
        }

        let timestamp = DateTime::from_timestamp_millis(market.timestamp_ms)?;

        // Determine direction based on spot vs reference
        let (direction, entry_price) = if spot_delta_pct > 0.0 {
            // BTC above reference → YES wins → buy YES if cheap
            if market.yes_ask <= self.config.cheap_threshold {
                (GabagoolDirection::Yes, market.yes_ask)
            } else {
                return None;
            }
        } else {
            // BTC below reference → NO wins → buy NO if cheap
            if market.no_ask <= self.config.cheap_threshold {
                (GabagoolDirection::No, market.no_ask)
            } else {
                return None;
            }
        };

        // Estimate edge: P(win) - cost
        // Win probability scales with how strongly spot confirms direction:
        // - At min_delta (0.05%), we have weak confirmation ~55%
        // - At 2x min_delta, stronger ~65%
        // - At 3x+ min_delta, cap at ~80%
        let entry_price_f64 = entry_price.to_string().parse::<f64>().unwrap_or(0.5);
        let delta_ratio = (abs_delta / self.config.min_reference_delta).min(3.0);
        let win_prob = 0.50 + 0.10 * delta_ratio; // 55% to 80%
        let estimated_edge = win_prob - entry_price_f64;

        Some(GabagoolSignal {
            signal_type: GabagoolSignalType::Entry,
            direction,
            entry_price,
            spot_price,
            reference_price: reference.reference_price,
            spot_delta_pct,
            current_pair_cost: market.pair_cost(),
            time_remaining_secs,
            timestamp,
            estimated_edge: estimated_edge.min(0.5), // Cap at 50%
            existing_entry_price: None,
            confidence: reference.confidence.into(),
        })
    }

    /// Checks for hedge opportunity (convert directional to pair arb).
    fn check_hedge(
        &self,
        position: &OpenPosition,
        reference: &WindowReference,
        spot_price: f64,
        market: &MarketSnapshot,
        time_remaining_secs: i64,
        spot_delta_pct: f64,
    ) -> Option<GabagoolSignal> {
        let timestamp = DateTime::from_timestamp_millis(market.timestamp_ms)?;

        // Calculate what pair cost would be if we hedge now
        let hedge_price = match position.direction {
            GabagoolDirection::Yes => market.no_ask,
            GabagoolDirection::No => market.yes_ask,
        };

        let effective_pair_cost = position.entry_price + hedge_price;

        // Can we lock in profit?
        if effective_pair_cost >= self.config.pair_cost_threshold {
            return None;
        }

        // Calculate locked profit per pair
        let profit_per_pair = Decimal::ONE - effective_pair_cost;
        let profit_f64 = profit_per_pair.to_string().parse::<f64>().unwrap_or(0.0);

        Some(GabagoolSignal {
            signal_type: GabagoolSignalType::Hedge,
            direction: position.direction.opposite(),
            entry_price: hedge_price,
            spot_price,
            reference_price: reference.reference_price,
            spot_delta_pct,
            current_pair_cost: market.pair_cost(),
            time_remaining_secs,
            timestamp,
            estimated_edge: profit_f64,
            existing_entry_price: Some(position.entry_price),
            confidence: reference.confidence.into(),
        })
    }

    /// Checks for scratch opportunity (exit before expiry).
    fn check_scratch(
        &self,
        position: &OpenPosition,
        reference: &WindowReference,
        spot_price: f64,
        market: &MarketSnapshot,
        time_remaining_secs: i64,
        spot_delta_pct: f64,
    ) -> Option<GabagoolSignal> {
        // Only scratch if we're close to expiry
        if time_remaining_secs > self.config.scratch_time_secs {
            return None;
        }

        let timestamp = DateTime::from_timestamp_millis(market.timestamp_ms)?;

        // Get exit price (we'd be selling, so use bid)
        let exit_price = match position.direction {
            GabagoolDirection::Yes => market.yes_bid,
            GabagoolDirection::No => market.no_bid,
        };

        // Calculate loss if we scratch
        let loss = position.entry_price - exit_price;

        // Only scratch if loss is within acceptable limit
        if loss > self.config.scratch_loss_limit {
            // Loss too large - might be better to hold and hope
            // But signal scratch anyway with low confidence
        }

        let loss_f64 = loss.to_string().parse::<f64>().unwrap_or(0.0);

        Some(GabagoolSignal {
            signal_type: GabagoolSignalType::Scratch,
            direction: position.direction, // Same direction (selling)
            entry_price: exit_price,       // Exit price
            spot_price,
            reference_price: reference.reference_price,
            spot_delta_pct,
            current_pair_cost: market.pair_cost(),
            time_remaining_secs,
            timestamp,
            estimated_edge: -loss_f64, // Negative = loss
            existing_entry_price: Some(position.entry_price),
            confidence: if loss <= self.config.scratch_loss_limit {
                SignalConfidence::High
            } else {
                SignalConfidence::Low
            },
        })
    }

    /// Resets the detector state.
    pub fn reset(&mut self) {
        self.open_position = None;
        self.last_signal_ms = None;
    }

    /// Resets just the cooldown.
    pub fn reset_cooldown(&mut self) {
        self.last_signal_ms = None;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::arbitrage::reference_tracker::ReferenceSource;

    fn make_reference(start_ms: i64, price: f64) -> WindowReference {
        WindowReference::new(start_ms, price, ReferenceSource::Manual, start_ms)
            .with_confidence(ReferenceConfidence::High)
    }

    fn make_time(minute: i64, second: i64) -> i64 {
        minute * 60 * 1000 + second * 1000
    }

    // =========================================================================
    // Entry Signal Tests
    // =========================================================================

    #[test]
    fn test_entry_signal_yes_btc_above_reference() {
        let mut detector = GabagoolDetector::with_defaults();

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_078.0; // +0.1% above reference

        let market = MarketSnapshot::from_asks(
            dec!(0.30),      // YES cheap
            dec!(0.70),      // NO expensive
            make_time(5, 0), // 5 min into window
        );

        let signal = detector.check(&reference, spot_price, &market);

        assert!(signal.is_some());
        let signal = signal.unwrap();
        assert_eq!(signal.signal_type, GabagoolSignalType::Entry);
        assert_eq!(signal.direction, GabagoolDirection::Yes);
        assert_eq!(signal.entry_price, dec!(0.30));
        assert!(signal.spot_delta_pct > 0.0);
    }

    #[test]
    fn test_entry_signal_no_btc_below_reference() {
        let mut detector = GabagoolDetector::with_defaults();

        let reference = make_reference(0, 78_000.0);
        let spot_price = 77_922.0; // -0.1% below reference

        let market = MarketSnapshot::from_asks(
            dec!(0.70), // YES expensive
            dec!(0.30), // NO cheap
            make_time(5, 0),
        );

        let signal = detector.check(&reference, spot_price, &market);

        assert!(signal.is_some());
        let signal = signal.unwrap();
        assert_eq!(signal.signal_type, GabagoolSignalType::Entry);
        assert_eq!(signal.direction, GabagoolDirection::No);
        assert_eq!(signal.entry_price, dec!(0.30));
        assert!(signal.spot_delta_pct < 0.0);
    }

    #[test]
    fn test_no_entry_prices_too_high() {
        let mut detector = GabagoolDetector::with_defaults();

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_100.0;

        let market = MarketSnapshot::from_asks(
            dec!(0.50), // Both at fair value
            dec!(0.50),
            make_time(5, 0),
        );

        let signal = detector.check(&reference, spot_price, &market);
        assert!(signal.is_none());
    }

    #[test]
    fn test_no_entry_delta_too_small() {
        let config = GabagoolConfig {
            min_reference_delta: 0.001, // Need 0.1%
            ..GabagoolConfig::default()
        };
        let mut detector = GabagoolDetector::new(config);

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_039.0; // Only +0.05%

        let market = MarketSnapshot::from_asks(dec!(0.30), dec!(0.70), make_time(5, 0));

        let signal = detector.check(&reference, spot_price, &market);
        assert!(signal.is_none());
    }

    #[test]
    fn test_no_entry_too_early_in_window() {
        let config = GabagoolConfig {
            min_window_elapsed_ms: 60_000, // Need 1 minute
            ..GabagoolConfig::default()
        };
        let mut detector = GabagoolDetector::new(config);

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_100.0;

        let market = MarketSnapshot::from_asks(
            dec!(0.30),
            dec!(0.70),
            make_time(0, 30), // Only 30 sec in
        );

        let signal = detector.check(&reference, spot_price, &market);
        assert!(signal.is_none());
    }

    // =========================================================================
    // Hedge Signal Tests
    // =========================================================================

    #[test]
    fn test_hedge_signal_when_pair_cost_low() {
        let mut detector = GabagoolDetector::with_defaults();

        // Record that we already have a YES position
        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.35),
            quantity: dec!(100),
            entry_time_ms: 0,
            window_start_ms: 0,
        });

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_100.0;

        // Now NO is also cheap - total would be 0.35 + 0.60 = 0.95
        let market = MarketSnapshot::from_asks(
            dec!(0.40),
            dec!(0.60), // NO now cheap enough
            make_time(5, 0),
        );

        let signal = detector.check(&reference, spot_price, &market);

        assert!(signal.is_some());
        let signal = signal.unwrap();
        assert_eq!(signal.signal_type, GabagoolSignalType::Hedge);
        assert_eq!(signal.direction, GabagoolDirection::No); // Opposite of position
        assert_eq!(signal.entry_price, dec!(0.60));
        assert_eq!(signal.existing_entry_price, Some(dec!(0.35)));
    }

    #[test]
    fn test_no_hedge_pair_cost_too_high() {
        let mut detector = GabagoolDetector::with_defaults();

        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.35),
            quantity: dec!(100),
            entry_time_ms: 0,
            window_start_ms: 0,
        });

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_100.0;

        // NO is expensive - total would be 0.35 + 0.68 = 1.03 (no profit)
        let market = MarketSnapshot::from_asks(dec!(0.40), dec!(0.68), make_time(5, 0));

        let signal = detector.check(&reference, spot_price, &market);

        // Should not signal hedge (pair cost too high), might signal scratch instead
        if let Some(s) = signal {
            assert_ne!(s.signal_type, GabagoolSignalType::Hedge);
        }
    }

    // =========================================================================
    // Scratch Signal Tests
    // =========================================================================

    #[test]
    fn test_scratch_signal_near_expiry() {
        let config = GabagoolConfig {
            scratch_time_secs: 180, // Scratch with 3 min left
            ..GabagoolConfig::default()
        };
        let mut detector = GabagoolDetector::new(config);

        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.35),
            quantity: dec!(100),
            entry_time_ms: 0,
            window_start_ms: 0,
        });

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_000.0; // Exactly at reference (uncertain)

        // 13 minutes in (2 min remaining) - should trigger scratch
        let market = MarketSnapshot::new(
            dec!(0.50), // YES ask
            dec!(0.34), // YES bid (sell at 0.34, loss of 0.01)
            dec!(0.50), // NO ask
            dec!(0.48), // NO bid
            make_time(13, 0),
        );

        let signal = detector.check(&reference, spot_price, &market);

        assert!(signal.is_some());
        let signal = signal.unwrap();
        assert_eq!(signal.signal_type, GabagoolSignalType::Scratch);
        assert_eq!(signal.direction, GabagoolDirection::Yes);
        assert_eq!(signal.entry_price, dec!(0.34)); // Exit at bid
    }

    #[test]
    fn test_no_scratch_if_time_remaining() {
        let config = GabagoolConfig {
            scratch_time_secs: 180,
            ..GabagoolConfig::default()
        };
        let mut detector = GabagoolDetector::new(config);

        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.35),
            quantity: dec!(100),
            entry_time_ms: 0,
            window_start_ms: 0,
        });

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_000.0;

        // 5 minutes in (10 min remaining) - no scratch yet
        let market = MarketSnapshot::new(
            dec!(0.50),
            dec!(0.34),
            dec!(0.50),
            dec!(0.48),
            make_time(5, 0),
        );

        let signal = detector.check(&reference, spot_price, &market);

        // Should not be a scratch signal
        if let Some(s) = signal {
            assert_ne!(s.signal_type, GabagoolSignalType::Scratch);
        }
    }

    // =========================================================================
    // Position Management Tests
    // =========================================================================

    #[test]
    fn test_record_and_clear_position() {
        let mut detector = GabagoolDetector::with_defaults();

        assert!(detector.open_position().is_none());

        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.35),
            quantity: dec!(100),
            entry_time_ms: 0,
            window_start_ms: 0,
        });

        assert!(detector.open_position().is_some());

        detector.record_exit();

        assert!(detector.open_position().is_none());
    }

    #[test]
    fn test_reset_clears_state() {
        let mut detector = GabagoolDetector::with_defaults();

        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.35),
            quantity: dec!(100),
            entry_time_ms: 0,
            window_start_ms: 0,
        });
        detector.last_signal_ms = Some(1000);

        detector.reset();

        assert!(detector.open_position().is_none());
        assert!(detector.last_signal_ms.is_none());
    }

    // =========================================================================
    // Cooldown Tests
    // =========================================================================

    #[test]
    fn test_signal_cooldown() {
        let mut detector = GabagoolDetector::with_defaults().with_cooldown(10_000);

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_100.0;

        let market1 = MarketSnapshot::from_asks(dec!(0.30), dec!(0.70), make_time(5, 0));
        let market2 = MarketSnapshot::from_asks(dec!(0.30), dec!(0.70), make_time(5, 5)); // 5 sec later

        let signal1 = detector.check(&reference, spot_price, &market1);
        assert!(signal1.is_some());

        let signal2 = detector.check(&reference, spot_price, &market2);
        assert!(signal2.is_none()); // Blocked by cooldown
    }

    #[test]
    fn test_cooldown_expires() {
        let mut detector = GabagoolDetector::with_defaults().with_cooldown(5_000);

        let reference = make_reference(0, 78_000.0);
        let spot_price = 78_100.0;

        let market1 = MarketSnapshot::from_asks(dec!(0.30), dec!(0.70), make_time(5, 0));
        let market2 = MarketSnapshot::from_asks(dec!(0.30), dec!(0.70), make_time(5, 10)); // 10 sec later

        let signal1 = detector.check(&reference, spot_price, &market1);
        assert!(signal1.is_some());

        // Need to reset position tracking since we got a signal but didn't actually enter
        // In real usage, record_entry would be called after actual fill
        detector.reset_cooldown();

        let signal2 = detector.check(&reference, spot_price, &market2);
        assert!(signal2.is_some()); // Cooldown expired
    }

    // =========================================================================
    // Config Tests
    // =========================================================================

    #[test]
    fn test_config_default() {
        let config = GabagoolConfig::default();
        assert_eq!(config.cheap_threshold, dec!(0.42));
        assert!((config.min_reference_delta - 0.0003).abs() < 0.0001);
        assert_eq!(config.pair_cost_threshold, dec!(0.97));
        assert_eq!(config.scratch_time_secs, 180);
    }

    #[test]
    fn test_config_aggressive() {
        let config = GabagoolConfig::aggressive();
        assert_eq!(config.cheap_threshold, dec!(0.48));
        assert!((config.min_reference_delta - 0.0002).abs() < 0.0001);
        assert_eq!(config.scratch_time_secs, 120);
    }

    #[test]
    fn test_config_conservative() {
        let config = GabagoolConfig::conservative();
        assert_eq!(config.cheap_threshold, dec!(0.35));
        assert!((config.min_reference_delta - 0.0005).abs() < 0.0001);
        assert_eq!(config.scratch_time_secs, 300);
    }

    // =========================================================================
    // Real Scenario Tests
    // =========================================================================

    #[test]
    fn test_real_scenario_btc_down_buy_no() {
        let mut detector = GabagoolDetector::with_defaults();

        // Real scenario: Reference $78,458.86, current $78,380.00 = DOWN by ~0.1%
        // (The original delta of $31 was only 0.039%, below the 0.05% threshold)
        let reference = make_reference(0, 78_458.86);
        let spot_price = 78_380.00; // -0.1% below reference (enough to trigger)

        // NO should be cheap since market hasn't reacted yet
        let market = MarketSnapshot::from_asks(dec!(0.60), dec!(0.32), make_time(5, 0));

        let signal = detector.check(&reference, spot_price, &market);

        assert!(signal.is_some());
        let signal = signal.unwrap();
        assert_eq!(signal.signal_type, GabagoolSignalType::Entry);
        assert_eq!(signal.direction, GabagoolDirection::No);
        assert!(signal.spot_delta_pct < 0.0);
    }

    #[test]
    fn test_full_lifecycle_entry_hedge() {
        let mut detector = GabagoolDetector::with_defaults();

        let reference = make_reference(0, 78_000.0);

        // 1. Entry: BTC up, YES cheap
        let spot1 = 78_100.0;
        let market1 = MarketSnapshot::from_asks(dec!(0.32), dec!(0.70), make_time(2, 0));

        let signal1 = detector.check(&reference, spot1, &market1);
        assert!(signal1.is_some());
        assert_eq!(
            signal1.as_ref().unwrap().signal_type,
            GabagoolSignalType::Entry
        );
        assert_eq!(signal1.unwrap().direction, GabagoolDirection::Yes);

        // Record the entry
        detector.record_entry(OpenPosition {
            direction: GabagoolDirection::Yes,
            entry_price: dec!(0.32),
            quantity: dec!(100),
            entry_time_ms: make_time(2, 0),
            window_start_ms: 0,
        });
        detector.reset_cooldown();

        // 2. Hedge: NO becomes cheap too
        let spot2 = 78_050.0; // BTC pulled back but still above ref
        let market2 = MarketSnapshot::from_asks(dec!(0.40), dec!(0.62), make_time(7, 0));

        let signal2 = detector.check(&reference, spot2, &market2);
        assert!(signal2.is_some());
        let signal2 = signal2.unwrap();
        assert_eq!(signal2.signal_type, GabagoolSignalType::Hedge);
        assert_eq!(signal2.direction, GabagoolDirection::No);
        // Pair cost: 0.32 + 0.62 = 0.94 < 0.97 threshold
    }

    #[test]
    fn test_direction_opposite() {
        assert_eq!(GabagoolDirection::Yes.opposite(), GabagoolDirection::No);
        assert_eq!(GabagoolDirection::No.opposite(), GabagoolDirection::Yes);
    }

    #[test]
    fn test_market_snapshot_pair_cost() {
        let market = MarketSnapshot::from_asks(dec!(0.45), dec!(0.52), 0);
        assert_eq!(market.pair_cost(), dec!(0.97));
    }
}
